/*
Web Modeler REST API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 41f4f56
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// FilesAPIService FilesAPI service
type FilesAPIService service

type ApiCreateFileRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	createFileDto *CreateFileDto
}

func (r ApiCreateFileRequest) CreateFileDto(createFileDto CreateFileDto) ApiCreateFileRequest {
	r.createFileDto = &createFileDto
	return r
}

func (r ApiCreateFileRequest) Execute() (*FileMetadataDto, *http.Response, error) {
	return r.ApiService.CreateFileExecute(r)
}

/*
CreateFile Method for CreateFile

This endpoint creates a file.<br/>
<br/>
To create a file, specify <em>projectId</em> and/or <em>folderId</em>:
<ul>
  <li><p>When only <em>folderId</em> is given, the file will be created in that
      folder. The folder can be in any project of the same organization.</p></li>
  <li><p>When <em>projectId</em> is given and <em>folderId</em> is either
      null or omitted altogether, the file will be created in the root of the project.</p></li>
  <li><p>When <em>projectId</em> and <em>folderId</em> are both given,
      they must be consistent - i.e. the folder is in the project.</p></li>
</ul>
<p>For connector templates, the following constraints apply:</p>
<ul>
  <li><p>The value of <em>content.$schema</em> will be replaced with
      <em>https://unpkg.com/@camunda/zeebe-element-templates-json-schema/resources/schema.json
      </em>
      and validated against it.</p></li>
  <li><p>The value of <em>name</em> takes precedence over <em>content.name</em>.
      In case of mismatch, the latter will be adjusted to match the former automatically.</p></li>
  <li><p>The value of <em>content.id</em> will be replaced with the file <em>id</em> generated by
      Web Modeler.</p></li>
  <li><p>The value of <em>content.version</em> is managed by Web Modeler and will be updated
      automatically.</p></li>
</ul>
<p>
  <strong>Note:</strong> The <code>simplePath</code> transforms any occurrences of slashes
  (<code>/</code>) in file and folder names into an escape sequence consisting of a backslash
  followed by a slash (<code>\/</code>). This form of escaping facilitates the processing of
  path-like structures within file and folder names.
</p>


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateFileRequest
*/
func (a *FilesAPIService) CreateFile(ctx context.Context) ApiCreateFileRequest {
	return ApiCreateFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FileMetadataDto
func (a *FilesAPIService) CreateFileExecute(r ApiCreateFileRequest) (*FileMetadataDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileMetadataDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.CreateFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/files"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createFileDto == nil {
		return localVarReturnValue, nil, reportError("createFileDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createFileDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteFileRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	fileId string
}

func (r ApiDeleteFileRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteFileExecute(r)
}

/*
DeleteFile Method for DeleteFile

Deletes a file.<br/>
<br/>
<strong>Note:</strong> Deleting a file will also delete other resources attached to the file (comments,
 call activity/business rule task links, milestones and shares) which might have side-effects.
 Deletion of resources is recursive and cannot be undone.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fileId
 @return ApiDeleteFileRequest
*/
func (a *FilesAPIService) DeleteFile(ctx context.Context, fileId string) ApiDeleteFileRequest {
	return ApiDeleteFileRequest{
		ApiService: a,
		ctx: ctx,
		fileId: fileId,
	}
}

// Execute executes the request
func (a *FilesAPIService) DeleteFileExecute(r ApiDeleteFileRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.DeleteFile")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/files/{fileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"fileId"+"}", url.PathEscape(parameterValueToString(r.fileId, "fileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetFileRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	fileId string
}

func (r ApiGetFileRequest) Execute() (*FileDto, *http.Response, error) {
	return r.ApiService.GetFileExecute(r)
}

/*
GetFile Method for GetFile

Retrieves a file.<br/>
<br/>
<p>
  <strong>Note:</strong> The <code>simplePath</code> transforms any occurrences of slashes
  (<code>/</code>) in file and folder names into an escape sequence consisting of a backslash
  followed by a slash (<code>\/</code>). This form of escaping facilitates the processing of
  path-like structures within file and folder names.
</p>


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fileId
 @return ApiGetFileRequest
*/
func (a *FilesAPIService) GetFile(ctx context.Context, fileId string) ApiGetFileRequest {
	return ApiGetFileRequest{
		ApiService: a,
		ctx: ctx,
		fileId: fileId,
	}
}

// Execute executes the request
//  @return FileDto
func (a *FilesAPIService) GetFileExecute(r ApiGetFileRequest) (*FileDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.GetFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/files/{fileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"fileId"+"}", url.PathEscape(parameterValueToString(r.fileId, "fileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPatchFileRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	fileId string
	updateFileDto *UpdateFileDto
}

func (r ApiPatchFileRequest) UpdateFileDto(updateFileDto UpdateFileDto) ApiPatchFileRequest {
	r.updateFileDto = &updateFileDto
	return r
}

func (r ApiPatchFileRequest) Execute() (*FileMetadataDto, *http.Response, error) {
	return r.ApiService.PatchFileExecute(r)
}

/*
PatchFile Method for PatchFile

This endpoint updates the content, name, or location of a file, or all at the same time.<br/>
<br/>
To move a file, specify <em>projectId</em> and/or <em>folderId</em>:
<ul>
  <li><p>When only <em>folderId</em> is given, the file will be moved to that
      folder. The folder can be in another project of the same organization.</p></li>
  <li><p>When <em>projectId</em> is given and <em>folderId</em> is either
      null or omitted altogether, the file will be moved to the root of the project.</p></li>
  <li><p>When <em>projectId</em> and <em>folderId</em> are both given,
      they must be consistent - i.e. the new parent folder is in the new project.</p></li>
</ul>
<p>The field <em>revision</em> holds the current revision of the file. This is used for detecting
and preventing concurrent modifications.</p>
<p>For connector templates, the following constraints apply:</p>
  <ul>
    <li><p>The value of <em>content.$schema</em> is not updatable.</p></li>
    <li><p>The value of <em>content.name</em> can only be changed via <em>name</em>.</p></li>
    <li><p>The value of <em>content.id</em> is not updatable.</p></li>
    <li><p>The value of <em>content.version</em> is managed by Web Modeler and will be updated
        automatically.</p></li>
  </ul>
  <p>
    <strong>Note:</strong> The <code>simplePath</code> transforms any occurrences of slashes
    (<code>/</code>) in file and folder names into an escape sequence consisting of a backslash
    followed by a slash (<code>\/</code>). This form of escaping facilitates the processing of
    path-like structures within file and folder names.
  </p>


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param fileId
 @return ApiPatchFileRequest
*/
func (a *FilesAPIService) PatchFile(ctx context.Context, fileId string) ApiPatchFileRequest {
	return ApiPatchFileRequest{
		ApiService: a,
		ctx: ctx,
		fileId: fileId,
	}
}

// Execute executes the request
//  @return FileMetadataDto
func (a *FilesAPIService) PatchFileExecute(r ApiPatchFileRequest) (*FileMetadataDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileMetadataDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.PatchFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/files/{fileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"fileId"+"}", url.PathEscape(parameterValueToString(r.fileId, "fileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateFileDto == nil {
		return localVarReturnValue, nil, reportError("updateFileDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateFileDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchFilesRequest struct {
	ctx context.Context
	ApiService *FilesAPIService
	pubSearchDtoFileMetadataDto *PubSearchDtoFileMetadataDto
}

func (r ApiSearchFilesRequest) PubSearchDtoFileMetadataDto(pubSearchDtoFileMetadataDto PubSearchDtoFileMetadataDto) ApiSearchFilesRequest {
	r.pubSearchDtoFileMetadataDto = &pubSearchDtoFileMetadataDto
	return r
}

func (r ApiSearchFilesRequest) Execute() (*PubSearchResultDtoFileMetadataDto, *http.Response, error) {
	return r.ApiService.SearchFilesExecute(r)
}

/*
SearchFiles Method for SearchFiles

Searches for files.<br/>
<ul>
  <li><p><em>filter</em> specifies which fields should match. Only items that match the given
   fields will be
   returned.</p>
   <p/><strong>Note:</strong> Date fields need to be specified in a format compatible with
   <code>java.time.ZonedDateTime</code>; for example <code>2023-09-20T11:31:20.206801604Z</code>.
   <br/><br/>
   You can use suffixes to match date ranges:
   <table>
    <thead>
     <tr><th>Modifier</th><th>Description</th></tr>
    </thead>
    <tbody>
     <tr><td>||/y</td><td>Within the year of the provided date</td></tr>
     <tr><td>||/M</td><td>Within the month of the provided date</td></tr>
     <tr><td>||/w</td><td>Within the week of the provided date</td></tr>
     <tr><td>||/d</td><td>Within the day of the provided date</td></tr>
     <tr><td>||/h</td><td>Within the hour of the provided date</td></tr>
     <tr><td>||/m</td><td>Within the minute of the provided date</td></tr>
     <tr><td>||/s</td><td>Within the second of the provided date</td></tr>
    </tbody>
   </table>
   <br/>
   <p>You can also use the following prefixes to filter before or after the date:</p>
   <table>
    <thead>
     <tr><th>Operator</th><th>Description</th></tr>
    </thead>
    <tbody>
     <tr><td>&lt;</td><td>Before the provided date</td></tr>
     <tr><td>&lt;=</td><td>On or before the provided date</td></tr>
     <tr><td>&gt;</td><td>After the provided date</td></tr>
     <tr><td>&gt;=</td><td>On or after the provided date</td></tr>
    </tbody>
   </table>
   <p>Operator and modifier can be combined. Example:
     <code>&gt;=2023-09-20T11:31:20.206801604Z||/y</code> returns all files within or after
     2023</p>
  </p></li>
  <li><p><em>sort</em> specifies by which fields and direction
   (<code>ASC</code>/<code>DESC</code>) the result
   should be sorted.</p></li>
  <p>
    <strong>Note:</strong> Sorting by <code>simplePath</code> and <code>canonicalPath</code> is
    not supported.
  </p>
  <li><p><em>page</em> specifies the page number to return.</p></li>
  <li><p><em>size</em> specifies the number of items per page. The default value is 10.</p></li>
</ul>
<p>
  <strong>Note:</strong> The <code>simplePath</code> transforms any occurrences of slashes
  (<code>/</code>) in file and folder names into an escape sequence consisting of a backslash
  followed by a slash (<code>\/</code>). This form of escaping facilitates the processing of
  path-like structures within file and folder names.
</p>


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchFilesRequest
*/
func (a *FilesAPIService) SearchFiles(ctx context.Context) ApiSearchFilesRequest {
	return ApiSearchFilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PubSearchResultDtoFileMetadataDto
func (a *FilesAPIService) SearchFilesExecute(r ApiSearchFilesRequest) (*PubSearchResultDtoFileMetadataDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PubSearchResultDtoFileMetadataDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FilesAPIService.SearchFiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/files/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pubSearchDtoFileMetadataDto == nil {
		return localVarReturnValue, nil, reportError("pubSearchDtoFileMetadataDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pubSearchDtoFileMetadataDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
